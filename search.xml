<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript作用域与闭包]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[JavaScript作用域与闭包JavaScript作用域问题​ JavaScript 有个特性称为作用域。尽管对于很多开发者来说，作用域的概念不容易理解，但它确实是JavaScript这门语言中非常重要的一个概念。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你获得更好的开发体验。 ​ 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名称冲突。 作用域为你的代码提供了一个安全层级 ，可以提升性能，跟踪 bug 并减少 bug。 JavaScript中的作用域 全局作用域 局部作用域（函数作用域） 块级作用域（try catch, 或者ES6的let、const关键字所创建） var、let、const 关键字 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，存在变量提升。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改（如果const定义的常量被赋值为一个引用数据类型，这个常量的引用不能修改，但是通过这个常量可以修改这个引用数据类型本身） 1234567891011121314// 关于变量提升的说明// 在js中函数声明、var定义的变量声明都会被提升console.log(a); // undefinedvar a = 10;// 上面这段代码在js编译器看来等价于var aconsole.log(a); // undefineda = 10;// 但是对于let 和 const定义的关键字来说, 编译器会直接报错！console.log(a); // ReferenceError: a is not definedlet a = 10; JavaScript闭包​ 简单的来说：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 ​ 下面我们来看一段代码，清晰地展示了闭包: 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果! 而，一般来说我们使用闭包主要来实现两种效果 第一、使用闭包可以在JavaScript中模拟块级作用域（在ES6 规范之前，js除了try catch之后全局作用域和函数作用域，使用闭包的形式用函数作用域来模拟块级作用域） 第二、闭包可以用于在对象中创建私有变量 对于目前大量使用ES6规范的情况下，使用闭包来模拟块级作用域的时候确实少了。但是在创建私有变量的情况中，暂时没有更完美的方法了。即使在ES6的情况下，私有变量也只是一个提案（在变量前加 #号）。 或者使用symbol类型的值来作为属性名，防止外部调用时一般的遍历方式访问，但是这种形式也可以使用 Object.getOwnPropertySymbols() 返回自身的Symol属性，或者Symbol.for()，获取具体的symbol类型的值来访问。 《你不知道的JavaScript （上卷）》​ 这本书中详细说明了作用域与闭包的问题，想要深入了解的话，可以去阅读。以下是第一部分的目录： 第1章 作用域是什么 第2章 词法作用域 第3章 函数作用域和块作用域 第4章 提升 第5章 作用域闭包]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深拷贝探究]]></title>
    <url>%2F2018%2F09%2F27%2FJavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JavaScript深拷贝1、JavaScript数据类型​ JavaScript数据类型分为两类：基本数据类型（也被称为原始类型 primitive type）和对象类型（也被称为引用数据类型 object type） 其中基本数据类型包括：null、boolean、undefined、string、number、symbol 引用数据类型包括：Array、Object、Function、Date等 2、javascript的变量的存储方式–栈（stack）和堆（heap） 栈（stack）：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址 堆（heap）：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。 ​ 3、javascript值传递与址传递​ 基本类型与引用类型最大的区别实际就是传值与传址的区别 ​ 值传递：基本类型采用的是值传递。 ​ 址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。 ​ 4、深拷贝与浅拷贝 浅拷贝：浅拷贝是拷贝引用，拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响 深拷贝：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响 5、JavaScript中实现一个深拷贝 第一种方法：使用JSON解析解决 12345let a = &#123; x:1, y:[1,2,4]&#125;let b = JSON.parse(JSON.stringify(a)); 第二种方法：使用递归解析解决 123456js中遍历一个对象的属性的方法:Object.keys() 仅仅返回自身的可枚举属性，不包括继承来的，更不包括Symbol属性Object.getOwnPropertyNames() 返回自身的可枚举和不可枚举属性。但是不包括Symbol属性Object.getOwnPropertySymbols() 返回自身的Symol属性for...in 可以遍历对象的自身的和继承的可枚举属性，不包含Symbol属性Reflect.ownkeys() 返回对象自身的所有属性，不管是否可枚举，也不管是否是Symbol。注意不包括继承的属性 经过查阅资料，自己整理思考之后，初步编写了一个简单的深拷贝函数： 12345678910111213141516171819202122232425262728function deepClone (obj) &#123; // 如果是简单数据类型则直接返回数据 if (isPrimitive(obj)) &#123; return obj &#125; // 判断拷贝对象是否是数组 let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 使用Reflect.ownKeys可以获取包括Symbol属性的所有属性的数组 Reflect.ownKeys(obj).forEach(i =&gt; &#123; if (typeof obj[i] === 'object') &#123; // 递归处理 newObj[i] = deepClone(obj[i]); &#125; else &#123; // 简单处理 Function的情况 newObj[i] = obj[i]; &#125; &#125;); return newObj;&#125; function isPrimitive(value)&#123; return (typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'boolean'|| typeof value === 'undefined' || value === null) &#125; 经过测试该方法可以处理常见的大多数的深拷贝问题（obj可以是嵌套的复杂json对象，包括Array，Object、Function、Symbol） 1234567891011121314151617181920212223let s1 = Symbol("first");let xm = &#123; name: '小明', age:18, lessons:['数学','语文','英语'], brothers:[&#123; name:"大明", age:19 &#125;,&#123; name:"小小明", age:17 &#125;], girlFriends:null, son:undefined, money: NaN, arr: new Object(&#123;a:1&#125;), [s1]:'test', say: function () &#123; console.log('-----1-----',) &#125;&#125;;console.log(deepClone(xm)) // 结果正确！ 但是在测试以及学习其他优秀的库（ lodash ）是如何实现深拷贝的过程中也发现了一些问题。针对目前自己编写的这个深拷贝函数， 1、对于JavaScript其他内置数据类型的支持不够。比如Date、Set、ArrayBuffer等，lodash使用Object.prototype.toString.call()方法处理了几乎所有的数据类型。如下： 12345678910111213141516171819202122232425262728/** `Object#toString` result references. */var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; 需要完善这个问题就是一个精细的活儿了，之后有时间想折腾了会考虑参照lodash的处理方式，使用更精确的类型判断方法来修改这个深拷贝的函数。当然在生产环境中还是推荐大家使用lodash这种成熟的库好（^-^)。 2、对于循环引用的问题没有处理，遇见循环应用的问题时会内存溢出、爆栈。 1234let a = &#123;&#125;;let b = &#123;a&#125;;a.b = b;console.log(deepClone2(a)) // RangeError: Maximum call stack size exceeded 其中lodash使用了一个stack来解决了这个问题 1234567// Check for circular references and return its corresponding clone. stack || (stack = new Stack); var stacked = stack.get(value); if (stacked) &#123; return stacked; &#125; stack.set(value, result); 我们也可以使用类似的思想来解决循环引用的问题。 12345678910111213141516171819202122232425function deepClone (obj) &#123; let stack = &#123;&#125;; function baseClone () &#123; if (isPrimitive(obj)) &#123; return obj; &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; Reflect.ownKeys(obj).forEach(i =&gt; &#123; if (typeof obj[i] === 'object') &#123; // 增加了记录被拷贝过的引用地址。以此来解决循环引用的问题 if (stack[obj[i]]) &#123; newObj[i] = stack[obj[i]] &#125; else &#123; stack[obj[i]] = obj[i]; newObj[i] = baseClone(obj[i]); &#125; &#125; else &#123; newObj[i] = obj[i]; &#125; &#125;); return newObj; &#125; return baseClone(obj)&#125; 参考 javascript中的深拷贝和浅拷贝？ JavaScript|MDN]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript类型问题]]></title>
    <url>%2F2018%2F09%2F26%2FJavaScript%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript类型问题​ JavaScript 类型的问题其实是个挺折磨人的话题, 不然也不会有 TypeScript 出现了。此篇博文主要记录与此相关的一些问题。有兴趣研究的同学可以去阅读 lodash 的源代码，学习在这种成熟的JS库中是如何处理类型问题以及如何进行类型判断的。 JavaScript内置类型* null * undefined * boolean * number * string * object * symbol (ES6中新增类型) ​ 除了object之外，其他统称为基本数据类型。object类型则包括Object 、Array 、Function 、Date等，我们一般也把它们称为引用数据类型。 基本数据类型的值存放在栈（Stack）中，而引用数据类型的值存放在堆（Heap）中，栈中只存放对它们的“引用” JavaScript常见的一些类型问题1、== 和 ===问题 相等（==） 比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 1234 1 == 1 // true"1" == 1 // true 1 == '1' // true 0 == false // true 严格相等（===） 一致运算符不会进行类型转换，仅当操作数严格相等时返回true 123453 === 3 // true3 === '3' // falsevar object1 = &#123;"value":"key"&#125;, object2=&#123;"value":"key"&#125;;object1 === object2 //falseundefined == null // true 可以很明显的看出，== 和===的区别就在于在判断的时候是否进行了自动的**类型转换**。需要注意的是ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的 。 2、如何判断JavaScript中变量的类型 typeof 主要用于判断数据是不是基本数据类型：String、Number、Object、Null、Undefined，但是无法判断出function（有些浏览器会出错，V8中能正常判断 ）、array、regExp 123456789console.log(typeof '');//stringconsole.log(typeof []);//objectconsole.log(typeof &#123;&#125;);//objectconsole.log(typeof 1);//numberconsole.log(typeof null);//objectconsole.log(typeof undefined);//undefinedconsole.log(typeof true);//booleanconsole.log(typeof function()&#123;&#125;);//functionconsole.log(typeof /\d/);//object instanceof instanceof 左操作数是一个类，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则返回true.而js中对象的类是通过初始化它们的构造函数来定义的。即instanceof的右操作数应当是一个函数。所有的对象都是object的实例。如果左操作数不是对象，则返回false,如果右操作数不是函数，则抛出typeError。 12345new String('foo') instanceof String; // truenew String('foo') instanceof Object; // true'foo' instanceof String; // false'foo' instanceof Object; // false Object.prototype.toString.call() 这是对象的一个原生原型扩展函数，用来精确的区分数据类型 1234567const toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 上述的3种类型判断方式都有各有利弊，typeof验证**基本数据类型**（除了null哦） 一般不会有什么问题，但是验证引用数据类型，则会出现各种谬误。instanceof用来验证一个对象是否是一个类的实例，但是由于JavaScript中所有引用数据类型都是继承自Object，所以没法判断对象的准确类型。Object.prototype.toString.call()虽然可以精确判断数据类型，但是在面对自定义的类型时也存在风险。（想一下，如果我重写了Array的toString方法） 3、基本数据类型以及引用数据类型的问题（值传递与引用传递）&gt; js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? ​ 简单点说, 对象是引用传递, 基础类型是值传递, 通过将基础类型包装 (boxing) 可以以引用的方式传递 。例如 a = new Number(1) 这时候a 就可以使用引用的方式传递了 ​ 这地方有一个有意思的小问题。用更严谨的技术说法，在JavaScript中没有所谓的引用传递而是传递引用，也叫作call-by sharing 。想要了解的同学可以看看Stack Overflow上的这个讨论Is JavaScript a pass-by-reference or pass-by-value language? 调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。 然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。 换句话来说 值传递：传内存拷贝 ​ 引用传递：传内存指针 ​ 共享传递（call-by sharing）:传内存指针的拷贝 4、JavaScript中值为false的值 null undefined “” (空字符串) NaN 0 false ​]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
</search>
