<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入Promise]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise%2F</url>
    <content type="text"><![CDATA[深入PromisePromise/A+规范 Promise 规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，有兴趣的可以去了解下，最终 ES6 中采用了 Promise/A+ 规范。在讲解 Promise 实现之前，当然要先了解 Promise/A+ 规范。Promise/A+ 规范参考： promisesaplus.com 其中有几个要点需要注意一下： Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆 then 方法可以被同一个 promise 调用多次。 then 方法必须返回一个 promise。规范里没有明确说明返回一个新的 promise 还是复用老的 promise（即 return this），大多数实现都是返回一个新的 promise，而且复用老的 promise 可能改变内部状态，这与规范也是相违背的。 实现一个简单的Promise Promise 初始化Promise对象存在3中状态： Pending(进行中) Fulfilled(已成功) Rejected(已失败) 状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。 resolve和reject resolve: 将promise对象的状态从Pending（进行中）变为Fulfilled（已完成） reject: 将Promise对象的状态从Pending（进行中）变为Rejected（已失败） resolve 和 reject 都可以传入任意类型的值作为实参，表示 Promise 对象成功（Fulfilled）和失败（Rejected）的值 123456789101112131415161718192021222324252627282930313233343536/** * 实现一个Promise */const PENDING = Symbol();const FULFILLED = Symbol();const REJECTED = Symbol();class MyPromise &#123; constructor (fn) &#123; if (typeof fn !== 'function') &#123; throw new Error('fn must be a function!'); &#125; this._status = PENDING; // 状态 this._value = null; // 执行fn try &#123; fn(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err); &#125; &#125; _resolve (val) &#123; if (this._status !== PENDING) return; this._status = FULFILLED; this._value = val; &#125; _reject (err) &#123; if (this._status !== PENDING) return; this._status = REJECTED; this._value = err; &#125;&#125; 这样我们就是实现了Promise状态和值的改变。接下来我们要实现Promise和核心：then方法 完善Promise实现Promise的then方法，Promise对象的then方法接受两个参数： 1promise.then(onFulfilled, onRejected) then方法中的两个参数如果不是函数，则必须被忽略。 如果onFulfilled是函数，则当Promise状态变为成功时，必须被调用，其中第一个参数为Promise成功状态传入的值（即resolve的值），只可以被调用一次。 如果onRejected是函数，则当Promise状态变为失败时，必须被调用，其中第一个参数为Promise失败状态传入的值（即reject的值），只可以被调用一次 then方法可以被同一个Promise对象调用多次，当Promise状态变为成功时，所有onFulfilled按照注册顺序依次回调；当Promise状态变为失败时，所有onRejected按照注册顺序依次回调 then 方法必须返回一个Promise(在ES6 以及大多数实现中都是返回一个新的Promise),因此Promise的then方法支持链式调用 特殊的需要注意Promise的值传递以及错误传递的机制。 修改构造函数：增加执行队列 123456789101112131415constructor (fn) &#123; if (typeof fn !== 'function') &#123; throw new Error('fn must be a function!'); &#125; this._status = PENDING; // 状态 this._value = null; this._fulfilledQueues = []; // 添加成功回调函数队列 this._rejectedQueues = []; // 添加失败回调函数执行队列 // 执行fn try &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; 添加then方法，并且需要将回调函数加入到执行队列中： 1234567891011121314151617then (onFulfilled, onRejected) &#123; switch (this._status) &#123; case PENDING: this._fulfilledQueues.push(onFulfilled); this._rejectedQueues.push(onRejected); break; case FULFILLED: onFulfilled(this._value); break; case REJECTED: onRejected(this._value); break; &#125; return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; &#125;); &#125; 完善then方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748then (onFulfilled, onRejected) &#123; return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; let fulfilled = (value) =&gt; &#123; try &#123; if (!(typeof onFulfilled === 'function')) &#123; onFulfilledNext(value); &#125; else &#123; let result = onFulfilled(value); if (result instanceof MyPromise) &#123; result.then(onFulfilledNext, onRejectedNext) &#125; else &#123; onFulfilledNext(result); &#125; &#125; &#125; catch (err) &#123; onRejectedNext(err); &#125; &#125;; let rejected = (error) =&gt; &#123; try &#123; if (!(typeof onRejected === 'function')) &#123; onRejectedNext(error); &#125; else &#123; let result = onRejected(error); if (result instanceof MyPromise) &#123; result.then(onFulfilledNext, onRejectedNext); &#125; else &#123; onFulfilledNext(result); &#125; &#125; &#125; catch (err) &#123; onRejectedNext(err); &#125; &#125;; switch (this._status) &#123; case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; case FULFILLED: fulfilled(this._value); break; case REJECTED: rejected(this._value); break; &#125; &#125;); &#125; then方法算是Promise的核心，then方法除了必须返回一个新的Promise之外（以便链式调用）；需要注意then中注册的两个回调函数也可能是一个Promise~；以上then函数的代码需要参照Promise的定义认真琢磨！ 接着修改 _resolve 和 _reject ：依次执行队列中的函数 当 resolve 或 reject方法执行时，我们依次提取成功或失败任务队列当中的函数开始执行，并清空队列，从而实现 then 方法的多次调用，实现的代码如下： 1234567891011121314151617181920212223242526272829_resolve (val) &#123; if (this._status !== PENDING) return; // 依次执行队列中的回调函数 const run = () =&gt; &#123; this._status = FULFILLED; this._value = val; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(val); &#125; &#125;; // 为了支持同步的Promise, setTimeout(run, 0); &#125; _reject (err) &#123; if (this._status !== PENDING) return; this._status = REJECTED; this._value = err; const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while (cb = this._rejectedQueues.shift())&#123; cb(err); &#125; &#125;; setTimeout(run, 0); &#125; 这里还有一种特殊的情况，就是当 resolve方法传入的参数为一个 Promise对象时，则该 Promise对象状态决定当前Promise对象的状态。我们需要修改_resolve来支持这样的特性： 123456789101112131415161718192021222324252627282930313233343536_resolve (val) &#123; // 依次执行队列中的回调函数 const run = () =&gt; &#123; if (this._status !== PENDING) return; const runFulfilled = (value) =&gt; &#123; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(value); &#125; &#125;; const runRejected = (error) =&gt; &#123; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(error); &#125; &#125;; if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value; this._status = FULFILLED; runFulfilled(value); &#125;, error =&gt; &#123; this._value = error; this._status = REJECTED; runRejected(error); &#125;); &#125; else &#123; this._value = val; this._status = FULFILLED; runFulfilled(val); &#125; &#125;; // 为了支持同步的Promise, setTimeout(run, 0); &#125; 这样一个基本的Promise就实现了。我们可以为他添加一些其他的方法 catch方法 相当于调用then方法，只需要注册Rejected状态的回调函数 1234// 添加catch方法catch (onRejected) &#123; return this.then(undefined, onRejected);&#125; 静态resolve方法 123456// 添加静态resolve方法static resolve (value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value return new MyPromise(resolve =&gt; resolve(value))&#125; 静态rejected方法 1234// 添加静态reject方法static reject (value) &#123; return new MyPromise((resolve ,reject) =&gt; reject(value))&#125; 静态all方法 12345678910111213141516171819// 添加静态all 方法static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let values = []; let count = 0; for (let i in list) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(list[i]).then(res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125;); &#125; &#125;); &#125; 静态race方法 123456789101112static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let v of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(v).then(res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125;); &#125; &#125;); &#125; finally方法 finally 方法用于指定不管 Promise对象最后状态如何，都会执行的操作 123456finally (cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 这样一个完整的Promise就实现了~ 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/** * 实现一个Promise */const PENDING = Symbol();const FULFILLED = Symbol();const REJECTED = Symbol();class MyPromise &#123; constructor (fn) &#123; if (typeof fn !== 'function') &#123; throw new Error('fn must be a function!'); &#125; this._status = PENDING; // 状态 this._value = null; this._fulfilledQueues = []; // 添加成功回调函数队列 this._rejectedQueues = []; // 添加失败回调函数执行队列 // 执行fn try &#123; fn(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; _resolve (val) &#123; // 依次执行队列中的回调函数 const run = () =&gt; &#123; if (this._status !== PENDING) return; const runFulfilled = (value) =&gt; &#123; let cb; while (cb = this._fulfilledQueues.shift()) &#123; cb(value); &#125; &#125;; const runRejected = (error) =&gt; &#123; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(error); &#125; &#125;; if (val instanceof MyPromise) &#123; val.then(value =&gt; &#123; this._value = value; this._status = FULFILLED; runFulfilled(value); &#125;, error =&gt; &#123; this._value = error; this._status = REJECTED; runRejected(error); &#125;); &#125; else &#123; this._value = val; this._status = FULFILLED; runFulfilled(val); &#125; &#125;; // 为了支持同步的Promise, setTimeout(run, 0); &#125; _reject (err) &#123; if (this._status !== PENDING) return; this._status = REJECTED; this._value = err; const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while (cb = this._rejectedQueues.shift()) &#123; cb(err); &#125; &#125;; setTimeout(run, 0); &#125; then (onFulfilled, onRejected) &#123; return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; let fulfilled = (value) =&gt; &#123; try &#123; if (!(typeof onFulfilled === 'function')) &#123; onFulfilledNext(value); &#125; else &#123; let result = onFulfilled(value); if (result instanceof MyPromise) &#123; result.then(onFulfilledNext, onRejectedNext); &#125; else &#123; onFulfilledNext(result); &#125; &#125; &#125; catch (err) &#123; onRejectedNext(err); &#125; &#125;; let rejected = (error) =&gt; &#123; try &#123; if (!(typeof onRejected === 'function')) &#123; onRejectedNext(error); &#125; else &#123; let result = onRejected(error); if (result instanceof MyPromise) &#123; result.then(onFulfilledNext, onRejectedNext); &#125; else &#123; onFulfilledNext(result); &#125; &#125; &#125; catch (err) &#123; onRejectedNext(err); &#125; &#125;; switch (this._status) &#123; case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; case FULFILLED: fulfilled(this._value); break; case REJECTED: rejected(this._value); break; &#125; &#125;); &#125; // 添加catch方法 catch (onRejected) &#123; return this.then(undefined, onRejected); &#125; static resolve (value) &#123; if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; static reject (error) &#123; return new MyPromise((resolve, reject) =&gt; reject(error)); &#125; static all (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let values = []; let count = 0; for (let i in list) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(list[i]).then(res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125;); &#125; &#125;); &#125; static race (list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let v of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(v).then(res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125;); &#125; &#125;); &#125; static finally (cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason;&#125;) ); &#125;&#125; 参考： ​ Promise实现原理]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配算法——BF和KMP算法]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94BF%E5%92%8CKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串模式匹配算法——BF和KMP算法​ 在字符串S中定位/查找某个子字符串P的操作，通常称为字符串的模式匹配，其中P称为模式串。模式匹配有多种算法，这里我先看一下最常见的BF算法和KMP算法。 BF（Brute—Force）算法​ BF（Brute Force)算法也就是传说中的“笨办法”，是一个暴力/蛮力算法。设串S和P的长度分别为m,n，则它在最坏情况下的时间复杂度是O(m*n)。BF算法的最坏时间复杂度虽然不好，但它易于理解和编程，在实际应用中，一般还能达到近似于O(m+n)的时间度（最坏情况不是那么容易出现的，RP问题），因此，还在被大量使用。 1234567891011121314151617181920212223242526272829/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;number&#125; */function strBF(s, p) &#123; if (p.length === 0) &#123; return 0; &#125; if (p.length &gt; s.length) &#123; return -1; &#125; for (let i = 0; i&lt;= s.length - p.length; i++) &#123; if (s[i] === p[0]) &#123; let flag = true; for (let j = 1; j &lt; p.length; j++) &#123; if (s[i+j] !== p[j]) &#123; flag = false; break; &#125; &#125; if (flag) &#123; return i; &#125; &#125; &#125; return -1;&#125;; KMP算法​ KMP算法，它是由D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。KMP算法可以在O(m+n)的时间里完成串的模式匹配。它的主要思想是：每当一趟匹配过程中出现字符不匹配时，不需回退i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽可能远的一段距离后，继续匹配过程。 ​ 对于KMP算法来说，核心是next数组的计算。next数组中每个值为模式字符串P中每个字符位置的真前缀和真后缀公共部分的最大长度。（ “真前缀”指除了自身以外，一个字符串的全部头部组合；”真后缀”指除了自身以外，一个字符串的全部尾部组合，这里加这个强调是为了区分与我们普通意义上的”前缀“和”后缀“） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function getNext (str) &#123; let i = 0; let j = -1; let next = []; next[0] = -1; while ( i &lt; str.length -1) &#123; if (j === -1 || str[i] === str[j]) &#123; i++; j++; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125;/** * * @param mainStr * @param pStr * @returns &#123;number&#125; */function KMP (mainStr, pStr) &#123; if (pStr.length === 0) &#123; return 0; &#125; if (pStr.length &gt; mainStr.length) &#123; return -1; &#125; let i = 0; let j = 0; let next = getNext(pStr); while (i &lt; mainStr.length &amp;&amp; j &lt; pStr.length) &#123; if (j === -1 || mainStr[i] === pStr[j]) &#123; i++; j++ &#125; else &#123; j = next[j]; &#125; &#125; if (j === pStr.length) &#123; return i - j; &#125; return -1;&#125; KMP优化​ KMP算法（未优化版）： next数组表示最长的相同真前后缀的长度，我们不仅可以利用next来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等。 ​ KMP算法（优化版）：优化后的next仅仅表示相同真前后缀的长度，但不一定是最长（称其为“最优相同真前后缀”更为恰当）。此时我们利用优化后的next可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。 1234567891011121314151617181920function getNext (str) &#123; let i = 0; let j = -1; let next = []; next[0] = -1; while ( i &lt; str.length -1) &#123; if (j === -1 || str[i] === str[j]) &#123; i++; j++; if (str[i] !== str[j]) &#123; next[i] = j; &#125; else &#123; // 字符相同就继续往前找真前缀 next[i] = next[j]; &#125; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法与数据结构</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆与堆排序]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆与堆排序​ 堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值 堆总是一棵完全二叉树 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。本篇博文我们来使用JavaScript来构建一个堆，并实现堆排序。 一、最大堆​ 根节点大于等于其叶子节点的堆被称为最大堆。虽然堆是一个树形结构，但是考虑到它是一个完全二叉树，有一个经典的实现就是使用数组来模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 最大堆 */class MaxHeap &#123; constructor (n) &#123; this.arr = []; // 模拟堆 this.count = 0; // 堆中元素数量 this.capacity = n; // 堆最大容量 &#125; insert (e) &#123; if (this.count &gt;= this.capacity) &#123; throw new RangeError('堆中空间已满！'); &#125; this.arr[this.count] = e; this._shiftUp(this.count); this.count++; &#125; extractMax () &#123; if (this.count &lt;= 0) &#123; throw new RangeError('堆中已无元素！'); &#125; let maxElement = this.arr[0]; this._swapArr(this.arr, 0, this.count - 1); this.count--; this._shiftDown(0); return maxElement; &#125; _shiftUp (k) &#123; while ((k - 1) &gt;&gt; 1 &gt;= 0 &amp;&amp; this.arr[k] &gt; this.arr[(k - 1) &gt;&gt; 1]) &#123; this._swapArr(this.arr, k, (k - 1) &gt;&gt; 1); k = (k - 1) &gt;&gt; 1; &#125; &#125; _shiftDown (k) &#123; while (2 * k + 1 &lt; this.count) &#123; let j = 2 * k + 1; if (j + 1 &lt; this.count &amp;&amp; this.arr[j + 1] &gt; this.arr[j]) &#123; j++; &#125; if (this.arr[j] &lt;= this.arr[k]) &#123; break; &#125; this._swapArr(this.arr, j, k); k = j; &#125; &#125; _swapArr (arr, m, n) &#123; let temp = arr[m]; arr[m] = arr[n]; arr[n] = temp; &#125;&#125; 二、最小堆​ 根节点小于等于其叶子节点的堆被称为最大堆。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 最小堆 */class MinHeap &#123; constructor (n) &#123; this.arr = []; // 模拟堆 this.count = 0; // 堆中元素数量 this.capacity = n; // 堆最大容量 &#125; insert (e) &#123; if (this.count &gt;= this.capacity) &#123; throw new RangeError('堆元素已满！'); &#125; this.arr[this.count] = e; this._shiftUp(this.count); this.count++; &#125; extractMin () &#123; if (this.count &lt;= 0) &#123; throw new RangeError('堆已经为空！'); &#125; let result = this.arr[0]; this._swap(0, this.count - 1); this.count--; this._shiftDown(0); return result; &#125; _shiftDown (k) &#123; while (2 * k + 1 &lt; this.count) &#123; let j = 2 * k + 1; if (j + 1 &lt; this.count &amp;&amp; this.arr[j + 1] &lt; this.arr[j]) &#123; j++; &#125; if (this.arr[k] &lt;= this.arr[j]) &#123; break; &#125; this._swap(k, j); k = j; &#125; &#125; _shiftUp (k) &#123; while ((k - 1) &gt;&gt; 1 &gt;= 0 &amp;&amp; this.arr[k] &lt; this.arr[(k - 1) &gt;&gt; 1]) &#123; this._swap(k, (k - 1) &gt;&gt; 1); k = (k - 1) &gt;&gt; 1; &#125; &#125; _swap (m, n) &#123; let temp = this.arr[m]; this.arr[m] = this.arr[n]; this.arr[n] = temp; &#125;&#125; 三、堆排序​ 堆排序就是使用了堆这种数据结构的思想，来优化排序速度的。 123456789101112131415161718192021// 使用上面的最大堆的类来进行排序function maxHeapSort (arr) &#123; let heap = new MaxHeap(arr.length); arr.forEach(v =&gt; &#123; heap.insert(v); &#125;); for (let i = arr.length - 1; i &gt;= 0; i--) &#123; arr[i] = heap.extractMax(); &#125;&#125;// 使用上面最小堆的类来进行排序function minHeapSort (arr) &#123; let heap = new MinHeap(arr.length); arr.forEach(v =&gt; &#123; heap.insert(v); &#125;); for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] = heap.extractMin(); &#125;&#125; ​ 对于以上堆排序的方法，我们是否可以考虑优化呢？答案当然是肯定的，在上面的堆排序算法中，我们额外使用一个空间为n的辅助堆，往这个堆中插入以及取出数据的时间复杂度都是O(nlogn)。通过查阅资料和学习我们可以知道，我们在进行堆排序时，我们并不需要辅助空间，直接在原地构建一个heap即可，这个行为过程有一个专有的名称叫做Heapify。 12345678910111213141516171819202122232425262728// 原地堆排序function heapSort (arr) &#123; // heapify for (let i = (arr.length - 1 - 1) &gt;&gt; 1; i &gt;= 0; i--) &#123; shiftDown(arr, i, arr.length); &#125; // 排序 for (let i = arr.length - 1; i &gt; 0; i--) &#123; swapArr(arr, 0, i); shiftDown(arr, 0, i); &#125;&#125;// 优化shiftDown,对比之前的代码，减少swap，改为直接赋值function shiftDown (arr, i, n) &#123; let temp = arr[i]; while (2 * i + 1 &lt; n) &#123; let j = 2 * i + 1; if (j + 1 &lt; n &amp;&amp; arr[j + 1] &gt; arr[j]) &#123; j++; &#125; if (temp &gt;= arr[j]) &#123; break; &#125; arr[i] = arr[j]; i = j; &#125; arr[i] = temp;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法与数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常见排序算法​ 算法与数据结构是我们计算机开发与学习中重要的基础，是每个开发者都应熟练掌握的内功，本篇博文主要记录一下常见的排序算法以及优化策略。 O(n^2)时间复杂度的简单排序算法选择排序​ 选择排序的思想很简单，遍历数组每次选出最大（最小）的值放置在合适的位置即可。 123456789101112131415161718192021222324252627// 交换数组两个位置的元素function swapArr (arr, m, n) &#123; let temp = arr[m]; arr[m] = arr[n]; arr[n] = temp;&#125;/** * 普通选择排序 */function selectSort (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组！'); &#125; if (arr.length &lt; 1) &#123; return; &#125; for (let m = 0; m &lt; arr.length; m++) &#123; let min = m; for (let n = m + 1; n &lt; arr.length; n++) &#123; if (arr[n] &lt; arr[min]) &#123; min = n; &#125; &#125; swapArr(arr, min, m); &#125;&#125; ​ 对于选择排序而言，我们有一个简单的优化策略——每次遍历同时选出最大值的最小值。这个优化方案有一个需要注意的点，当我们每次遍历选出最大值和最小值后，需要进行两次交换，需要考虑修正的情况。（假设排序的最大值在当前最小值的位置，先交换了最小值，此时最大值的位置也交换了，需要处理~^~） 123456789101112131415161718192021222324252627282930313233/** * 优化选择排序-每次选出最大值和最小值 */function selectSortAdvance (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组！'); &#125; if (arr.length &lt; 1) &#123; return; &#125; let leftIndex = 0; let rightIndex = arr.length - 1; while (leftIndex &lt; rightIndex) &#123; let min = leftIndex; let max = rightIndex; for (let n = leftIndex; n &lt;= rightIndex; n++) &#123; if (arr[min] &gt; arr[n]) &#123; min = n; &#125; if (arr[max] &lt; arr[n]) &#123; max = n; &#125; &#125; // 考虑修正的情况，最大值在最小位置。 swapArr(arr, min, leftIndex); if (max === leftIndex) &#123; max = min; &#125; swapArr(arr, max, rightIndex); leftIndex++; rightIndex--; &#125;&#125; 冒泡排序​ 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成 。 123456789101112131415161718/** * 冒泡排序 */function bubbleSort (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组！'); &#125; if (arr.length &lt;= 1) &#123; return; &#125; for (let m = 0; m &lt; arr.length; m++) &#123; for (let n = 0; n &lt; arr.length; n++) &#123; if (arr[n] &gt; arr[n + 1]) &#123; swapArr(arr, n, n + 1); &#125; &#125; &#125;&#125; ​ 对于此冒泡排序的实现，我们可以发现，每经过一次冒泡，最大值已经放置在了合适的位置，所以在内层的循环中可以不必考虑正确位置的比较。 123456789101112131415161718/** * 优化的冒泡排序 */function bubbleSortAdvance (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组'); &#125; if (arr.length &lt;= 1) &#123; return; &#125; for (let m = 0; m &lt; arr.length - 1; m++) &#123; for (let n = 0; n &lt; arr.length - 1 - m; n++) &#123; if (arr[n] &gt; arr[n + 1]) &#123; swapArr(arr, n, n + 1); &#125; &#125; &#125;&#125; ​ 在查阅资料以及学习的过程中发现，其实冒泡排序还能进行更近一步的优化，当每次排序时，发现之后所有的元素都已经有序时，可以记录这个位置，下一次冒泡只考虑前面的元素即可。 12345678910111213141516171819function bubbleSortBest (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组'); &#125; if (arr.length &lt;= 1) &#123; return; &#125; let index = arr.length - 1; let temp = 0; for (let m = 0; m &lt; arr.length - 1; m++) &#123; for (let n = 0; n &lt; index; n++) &#123; if (arr[n] &gt; arr[n + 1]) &#123; swapArr(arr, n, n + 1); temp = n + 1; &#125; &#125; index = temp; &#125;&#125; ​ 如果要求更高的话，我们可以发现外层for循环，其实还可以做一些小调整，循环次数可以减少。 插入排序​ 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 （很类似大多数人玩扑克牌时，抓牌时的策略） 12345678910111213141516171819202122/** * 直接插入排序 */function insertSort (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组'); &#125; if (arr.length &lt;= 1) &#123; return; &#125; for (let m = 1; m &lt; arr.length; m++) &#123; let temp = arr[m]; let insertIndex = m; for (let n = m - 1; n &gt;= 0; n--) &#123; if (arr[n] &gt; temp) &#123; arr[n + 1] = arr[n]; insertIndex--; &#125; &#125; arr[insertIndex] = temp; &#125;&#125; ​ 根据插入排序的思想我们可以知道，插入排序前半部分的数组一定是有序的，所以想要快速找到待插入元素正确的插入位置，可以使用二分查找的思想。 123456789101112131415161718192021222324252627282930313233343536373839/** * 二分插入排序 */function binarySearchInsertSort (arr) &#123; if (!Array.isArray(arr)) &#123; throw new TypeError('传入参数必须为数组'); &#125; if (arr.length &lt;= 1) &#123; return; &#125; for (let m = 1; m &lt; arr.length; m++) &#123; let temp = arr[m]; let index = binarySearch(arr, m - 1, temp); for (let n = m - 1; n &gt;= index; n--) &#123; arr[n + 1] = arr[n]; &#125; arr[index] = temp; &#125;&#125;// 二分查找，(如果元素不存在，返回二分查找最后一步较大值的位置)function binarySearch (arr, length, target) &#123; let l = 0; let r = length; while (l &lt;= r) &#123; // 防止整形溢出的 // let mid = Math.floor((l + r) / 2); let mid = l + ((r - l) &gt;&gt; 1); if (arr[mid] === target) &#123; return mid; &#125; if (arr[mid] &gt; target) &#123; r = mid - 1; &#125; if (arr[mid] &lt; target) &#123; l = mid + 1; &#125; &#125; return r + 1;&#125; O(nlogn)时间复杂度的排序算法归并排序​ 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 12345678910111213141516171819202122232425262728293031/** * 归并排序-递归法实现 */function mergeSort (arr, left, right) &#123; if (left &gt;= right) &#123; return; &#125; let mid = left + ((right - left) &gt;&gt; 1); mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right);&#125;function merge (arr, left, mid, right) &#123; let temp = []; for (let i = left; i &lt;= right; i++) &#123; temp[i] = arr[i]; &#125; let m = left; let n = mid + 1; for (let k = left; k &lt;= right; k++) &#123; if (m &gt; mid) &#123; arr[k] = temp[n++]; &#125; else if (n &gt; right) &#123; arr[k] = temp[m++]; &#125; else if (temp[m] &lt; temp[n]) &#123; arr[k] = temp[m++]; &#125; else &#123; arr[k] = temp[n++]; &#125; &#125;&#125; ​ 对于以上递归实现的归并排序，有两个小点可以优化. 12345678910111213141516171819202122232425262728293031323334function mergeSort (arr, left, right) &#123; // 优化1：当数组长度小于一定时，使用直接插入排序 if( right - left &lt;= 15 )&#123; insertionSort(arr, l, r); return; &#125; let mid = left + ((right - left) &gt;&gt; 1); mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // 优化2：前半部分最大值都比后半部分最小值都小的情况，不进行归并 // 使算法对基本有序数组的排序效率大大增加 if (arr[mid] &gt; arr[mid+1]) &#123; merge(arr, left, mid, right); &#125;&#125;function merge (arr, left, mid, right) &#123; let temp = []; for (let i = left; i &lt;= right; i++) &#123; temp[i] = arr[i]; &#125; let m = left; let n = mid + 1; for (let k = left; k &lt;= right; k++) &#123; if (m &gt; mid) &#123; arr[k] = temp[n++]; &#125; else if (n &gt; right) &#123; arr[k] = temp[m++]; &#125; else if (temp[m] &lt; temp[n]) &#123; arr[k] = temp[m++]; &#125; else &#123; arr[k] = temp[n++]; &#125; &#125;&#125; ​ 使用递归法实现一个算法时，优点是思路清楚，缺点是递归函数会频繁的调用自身，递归次数过多时可能会发生栈溢出的情况，所以在实际应用中，我们应该考虑使用迭代法，来实现归并排序。 12345678910/** * 归并排序-迭代法（自低而上） */function mergeSortBU (arr) &#123; for (let size = 1; size &lt; arr.length; size = 2 * size) &#123; for (let i = 0; i &lt; arr.length - size; i = i + 2 * size) &#123; merge(arr, i, i + size - 1, Math.min(arr.length - 1, i + 2 * size - 1)); &#125; &#125;&#125; ​ 对于迭代法而言，同样也可以使用插入排序来优化。对于有序的两个子项，不进行merge操作 123456789101112131415function mergeSortBU (arr) &#123; // 数据少时使用插入排序优化 for (let i = 0; i &lt; arr.length; i += 16) &#123; insertSort(arr, i, Math.min(i + 15, arr.length - 1)); &#125; for (let size = 1; size &lt; arr.length; size = 2 * size) &#123; for (let i = 0; i &lt; arr.length - size; i = i + 2 * size) &#123; // 有序的情况下，不进行merge if (arr[i + size - 1] &gt; arr[i + size) &#123; merge(arr, i, i + size - 1, Math.min(arr.length - 1, i + 2 * size - 1)); &#125; &#125; &#125;&#125; 快速排序​ 快速排序的思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617181920212223/** * 快速排序-递归-使用快慢指针 */function quickSort (arr, l, r) &#123; if (l &gt;= r) &#123; return; &#125; let p = partition(arr, l, r); quickSort(arr, l, p - 1); quickSort(arr, p + 1, r);&#125;// 快慢指针法function partition (arr, l, r) &#123; let p = l; for (let i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; arr[l]) &#123; p++; swapArr(arr, p, i); &#125; &#125; swapArr(arr, l, p); return p;&#125; ​ 以上代码应该算是quickSort最简单的实现了，但是这个实现中有一个严重的缺陷，当我们的待排序数组已经是几乎有序的时候，我们直接选取第一个元素为标定点P的时候quickSort会退化为时间复杂度为O(n^2)级别的算法，所有我们可以随机选取标定点P可以解决这个问题。同时在小数组的时候使用插入排序，也是一种通用的优化策略。 123456789101112131415161718192021222324function _quickSort (arr, l, r) &#123; // 当数据量小时，使用插入排序优化 if (r - l &lt; 22) &#123; insertSort(arr, l, r); return; &#125; let p = _partition(arr, l, r); _quickSort(arr, l, p - 1); _quickSort(arr, p + 1, r);&#125;// 快慢指针法function _partition (arr, l, r) &#123; // 随机选取标定点，解决快排在有序的情况下退化为O(n^2)级别的算法 swapArr(arr, l, Math.floor(Math.random() * (r - l + 1)) + l); let p = l; for (let i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; arr[l]) &#123; p++; swapArr(arr, p, i); &#125; &#125; swapArr(arr, l, p); return p;&#125; ​ 除了排序数组近乎有序的情况下，当数组中存在大量重复值的时候，也可能出现算法时间复杂度退化为O(n^2)的情况。这时候我们可以使用二路快排的算法优化。二路快排的核心思想就是从数组两端开始扫描，即使遇到与标的点P相等的数据时，也进行交换位置。这样就使得quickSort在进行partition操作的时候将数组分为平衡的两个部分。 12345678910111213141516171819202122232425262728293031323334function _quickSortTwoWay (arr, l, r) &#123; // 当数据量小时，使用插入排序优化 if (r - l &lt; 22) &#123; insertSort(arr, l, r); return; &#125; let p = _partition2(arr, l, r); _quickSort(arr, l, p - 1); _quickSort(arr, p + 1, r);&#125;function _partition2 (arr, l, r) &#123; // 随机选取标定点 swapArr(arr, l, Math.floor(Math.random() * (r - l + 1)) + l); let i = l + 1; let j = r; while (true) &#123; if (i &lt;= r &amp;&amp; arr[i] &lt; arr[l]) &#123; i++; &#125; if (j &gt;= l + 1 &amp;&amp; arr[j] &gt; arr[l]) &#123; j--; &#125; if (i &gt; j) &#123; break; &#125; swapArr(arr, i, j); i++; j--; &#125; swapArr(arr, l, j); return j;&#125; ​ 基于二路快排的思想，我们可以发现其实我们重复的移动了与标定点P数值相等的元素，那么我们可以找到一种方法减少这种重复且无用的操作吗？答案当然是，这也就是quickSort最经典的优化三路快排。 12345678910111213141516171819202122232425262728293031323334// 三路快排function _quickSortThreeWay (arr, l, r) &#123; // 当数据量小时，使用插入排序优化 if (r - l &lt; 22) &#123; insertSort(arr, l, r); return; &#125; let range = _partition3(arr, l, r); _quickSortThreeWay(arr, l, range.lt); _quickSortThreeWay(arr, range.gt, r);&#125;function _partition3 (arr, l, r) &#123; swapArr(arr, l, Math.floor(Math.random() * (r - l + 1)) + l); let lt = l + 1; // arr[l,lt) &lt; v let gt = r; // arr(gt,r] &gt; v let i = l + 1; while (i &lt;= gt) &#123; if (arr[i] &gt; arr[l]) &#123; swapArr(arr, i, gt); gt--; &#125; else if (arr[i] &lt; arr[l]) &#123; swapArr(arr, lt, i); lt++; i++; &#125; else &#123; i++; &#125; &#125; return &#123; lt: lt - 1, gt: gt + 1, &#125;;&#125; 未完待续​ 对于排序算法而言，以上列出的种种只是冰山一角，之后有兴趣的时候在一一完善记录吧~ ​ （堆排序、希尔排序、计数排序、桶排序……） ​]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法与数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript作用域与闭包]]></title>
    <url>%2F2018%2F10%2F10%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[JavaScript作用域与闭包JavaScript作用域问题​ JavaScript 有个特性称为作用域。尽管对于很多开发者来说，作用域的概念不容易理解，但它确实是JavaScript这门语言中非常重要的一个概念。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你获得更好的开发体验。 ​ 作用域（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名称冲突。 作用域为你的代码提供了一个安全层级 ，可以提升性能，跟踪 bug 并减少 bug。 JavaScript中的作用域 全局作用域 局部作用域（函数作用域） 块级作用域（try catch, 或者ES6的let、const关键字所创建） var、let、const 关键字 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问，存在变量提升。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改（如果const定义的常量被赋值为一个引用数据类型，这个常量的引用不能修改，但是通过这个常量可以修改这个引用数据类型本身） 1234567891011121314// 关于变量提升的说明// 在js中函数声明、var定义的变量声明都会被提升console.log(a); // undefinedvar a = 10;// 上面这段代码在js编译器看来等价于var aconsole.log(a); // undefineda = 10;// 但是对于let 和 const定义的关键字来说, 编译器会直接报错！console.log(a); // ReferenceError: a is not definedlet a = 10; JavaScript闭包​ 简单的来说：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 ​ 下面我们来看一段代码，清晰地展示了闭包: 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果! 而，一般来说我们使用闭包主要来实现两种效果 第一、使用闭包可以在JavaScript中模拟块级作用域（在ES6 规范之前，js除了try catch之后全局作用域和函数作用域，使用闭包的形式用函数作用域来模拟块级作用域） 第二、闭包可以用于在对象中创建私有变量 对于目前大量使用ES6规范的情况下，使用闭包来模拟块级作用域的时候确实少了。但是在创建私有变量的情况中，暂时没有更完美的方法了。即使在ES6的情况下，私有变量也只是一个提案（在变量前加 #号）。 或者使用symbol类型的值来作为属性名，防止外部调用时一般的遍历方式访问，但是这种形式也可以使用 Object.getOwnPropertySymbols() 返回自身的Symol属性，或者Symbol.for()，获取具体的symbol类型的值来访问。 《你不知道的JavaScript （上卷）》​ 这本书中详细说明了作用域与闭包的问题，想要深入了解的话，可以去阅读。以下是第一部分的目录： 第1章 作用域是什么 第2章 词法作用域 第3章 函数作用域和块作用域 第4章 提升 第5章 作用域闭包]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深拷贝探究]]></title>
    <url>%2F2018%2F09%2F27%2FJavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JavaScript深拷贝1、JavaScript数据类型​ JavaScript数据类型分为两类：基本数据类型（也被称为原始类型 primitive type）和对象类型（也被称为引用数据类型 object type） 其中基本数据类型包括：null、boolean、undefined、string、number、symbol 引用数据类型包括：Array、Object、Function、Date等 2、javascript的变量的存储方式–栈（stack）和堆（heap） 栈（stack）：自动分配内存空间，系统自动释放，里面存放的是基本类型的值和引用类型的地址 堆（heap）：动态分配的内存，大小不定，也不会自动释放。里面存放引用类型的值。 ​ 3、javascript值传递与址传递​ 基本类型与引用类型最大的区别实际就是传值与传址的区别 ​ 值传递：基本类型采用的是值传递。 ​ 址传递：引用类型则是地址传递，将存放在栈内存中的地址赋值给接收的变量。 ​ 4、深拷贝与浅拷贝 浅拷贝：浅拷贝是拷贝引用，拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响 深拷贝：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响 5、JavaScript中实现一个深拷贝 第一种方法：使用JSON解析解决 12345let a = &#123; x:1, y:[1,2,4]&#125;let b = JSON.parse(JSON.stringify(a)); 第二种方法：使用递归解析解决 123456js中遍历一个对象的属性的方法:Object.keys() 仅仅返回自身的可枚举属性，不包括继承来的，更不包括Symbol属性Object.getOwnPropertyNames() 返回自身的可枚举和不可枚举属性。但是不包括Symbol属性Object.getOwnPropertySymbols() 返回自身的Symol属性for...in 可以遍历对象的自身的和继承的可枚举属性，不包含Symbol属性Reflect.ownkeys() 返回对象自身的所有属性，不管是否可枚举，也不管是否是Symbol。注意不包括继承的属性 经过查阅资料，自己整理思考之后，初步编写了一个简单的深拷贝函数： 12345678910111213141516171819202122232425262728function deepClone (obj) &#123; // 如果是简单数据类型则直接返回数据 if (isPrimitive(obj)) &#123; return obj &#125; // 判断拷贝对象是否是数组 let newObj = Array.isArray(obj) ? [] : &#123;&#125;; // 使用Reflect.ownKeys可以获取包括Symbol属性的所有属性的数组 Reflect.ownKeys(obj).forEach(i =&gt; &#123; if (typeof obj[i] === 'object') &#123; // 递归处理 newObj[i] = deepClone(obj[i]); &#125; else &#123; // 简单处理 Function的情况 newObj[i] = obj[i]; &#125; &#125;); return newObj;&#125; function isPrimitive(value)&#123; return (typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'boolean'|| typeof value === 'undefined' || value === null) &#125; 经过测试该方法可以处理常见的大多数的深拷贝问题（obj可以是嵌套的复杂json对象，包括Array，Object、Function、Symbol） 1234567891011121314151617181920212223let s1 = Symbol("first");let xm = &#123; name: '小明', age:18, lessons:['数学','语文','英语'], brothers:[&#123; name:"大明", age:19 &#125;,&#123; name:"小小明", age:17 &#125;], girlFriends:null, son:undefined, money: NaN, arr: new Object(&#123;a:1&#125;), [s1]:'test', say: function () &#123; console.log('-----1-----',) &#125;&#125;;console.log(deepClone(xm)) // 结果正确！ 但是在测试以及学习其他优秀的库（ lodash ）是如何实现深拷贝的过程中也发现了一些问题。针对目前自己编写的这个深拷贝函数， 1、对于JavaScript其他内置数据类型的支持不够。比如Date、Set、ArrayBuffer等，lodash使用Object.prototype.toString.call()方法处理了几乎所有的数据类型。如下： 12345678910111213141516171819202122232425262728/** `Object#toString` result references. */var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]'; 需要完善这个问题就是一个精细的活儿了，之后有时间想折腾了会考虑参照lodash的处理方式，使用更精确的类型判断方法来修改这个深拷贝的函数。当然在生产环境中还是推荐大家使用lodash这种成熟的库好（^-^)。 2、对于循环引用的问题没有处理，遇见循环应用的问题时会内存溢出、爆栈。 1234let a = &#123;&#125;;let b = &#123;a&#125;;a.b = b;console.log(deepClone2(a)) // RangeError: Maximum call stack size exceeded 其中lodash使用了一个stack来解决了这个问题 1234567// Check for circular references and return its corresponding clone. stack || (stack = new Stack); var stacked = stack.get(value); if (stacked) &#123; return stacked; &#125; stack.set(value, result); 我们也可以使用类似的思想来解决循环引用的问题。 12345678910111213141516171819202122232425function deepClone (obj) &#123; let stack = &#123;&#125;; function baseClone () &#123; if (isPrimitive(obj)) &#123; return obj; &#125; let newObj = Array.isArray(obj) ? [] : &#123;&#125;; Reflect.ownKeys(obj).forEach(i =&gt; &#123; if (typeof obj[i] === 'object') &#123; // 增加了记录被拷贝过的引用地址。以此来解决循环引用的问题 if (stack[obj[i]]) &#123; newObj[i] = stack[obj[i]] &#125; else &#123; stack[obj[i]] = obj[i]; newObj[i] = baseClone(obj[i]); &#125; &#125; else &#123; newObj[i] = obj[i]; &#125; &#125;); return newObj; &#125; return baseClone(obj)&#125; 参考 javascript中的深拷贝和浅拷贝？ JavaScript|MDN]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript类型问题]]></title>
    <url>%2F2018%2F09%2F26%2FJavaScript%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript类型问题​ JavaScript 类型的问题其实是个挺折磨人的话题, 不然也不会有 TypeScript 出现了。此篇博文主要记录与此相关的一些问题。有兴趣研究的同学可以去阅读 lodash 的源代码，学习在这种成熟的JS库中是如何处理类型问题以及如何进行类型判断的。 JavaScript内置类型* null * undefined * boolean * number * string * object * symbol (ES6中新增类型) ​ 除了object之外，其他统称为基本数据类型。object类型则包括Object 、Array 、Function 、Date等，我们一般也把它们称为引用数据类型。 基本数据类型的值存放在栈（Stack）中，而引用数据类型的值存放在堆（Heap）中，栈中只存放对它们的“引用” JavaScript常见的一些类型问题1、== 和 ===问题 相等（==） 比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 1234 1 == 1 // true"1" == 1 // true 1 == '1' // true 0 == false // true 严格相等（===） 一致运算符不会进行类型转换，仅当操作数严格相等时返回true 123453 === 3 // true3 === '3' // falsevar object1 = &#123;"value":"key"&#125;, object2=&#123;"value":"key"&#125;;object1 === object2 //falseundefined == null // true 可以很明显的看出，== 和===的区别就在于在判断的时候是否进行了自动的**类型转换**。需要注意的是ECMAScript认为undefined是从null派生出来的，所以把它们定义为相等的 。 2、如何判断JavaScript中变量的类型 typeof 主要用于判断数据是不是基本数据类型：String、Number、Object、Null、Undefined，但是无法判断出function（有些浏览器会出错，V8中能正常判断 ）、array、regExp 123456789console.log(typeof '');//stringconsole.log(typeof []);//objectconsole.log(typeof &#123;&#125;);//objectconsole.log(typeof 1);//numberconsole.log(typeof null);//objectconsole.log(typeof undefined);//undefinedconsole.log(typeof true);//booleanconsole.log(typeof function()&#123;&#125;);//functionconsole.log(typeof /\d/);//object instanceof instanceof 左操作数是一个类，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则返回true.而js中对象的类是通过初始化它们的构造函数来定义的。即instanceof的右操作数应当是一个函数。所有的对象都是object的实例。如果左操作数不是对象，则返回false,如果右操作数不是函数，则抛出typeError。 12345new String('foo') instanceof String; // truenew String('foo') instanceof Object; // true'foo' instanceof String; // false'foo' instanceof Object; // false Object.prototype.toString.call() 这是对象的一个原生原型扩展函数，用来精确的区分数据类型 1234567const toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(undefined); // [object Undefined]toString.call(null); // [object Null] 上述的3种类型判断方式都有各有利弊，typeof验证**基本数据类型**（除了null哦） 一般不会有什么问题，但是验证引用数据类型，则会出现各种谬误。instanceof用来验证一个对象是否是一个类的实例，但是由于JavaScript中所有引用数据类型都是继承自Object，所以没法判断对象的准确类型。Object.prototype.toString.call()虽然可以精确判断数据类型，但是在面对自定义的类型时也存在风险。（想一下，如果我重写了Array的toString方法） 3、基本数据类型以及引用数据类型的问题（值传递与引用传递）&gt; js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? ​ 简单点说, 对象是引用传递, 基础类型是值传递, 通过将基础类型包装 (boxing) 可以以引用的方式传递 。例如 a = new Number(1) 这时候a 就可以使用引用的方式传递了 ​ 这地方有一个有意思的小问题。用更严谨的技术说法，在JavaScript中没有所谓的引用传递而是传递引用，也叫作call-by sharing 。想要了解的同学可以看看Stack Overflow上的这个讨论Is JavaScript a pass-by-reference or pass-by-value language? 调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。 然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。 换句话来说 值传递：传内存拷贝 ​ 引用传递：传内存指针 ​ 共享传递（call-by sharing）:传内存指针的拷贝 4、JavaScript中值为false的值 null undefined “” (空字符串) NaN 0 false ​]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>基础问题</tag>
      </tags>
  </entry>
</search>
